#  blast_res[2, "tax_id"] <- 3333333
blast_res$staxids[which(!is.na(blast_res$tax_id))] <- blast_res$tax_id[which(!is.na(blast_res$tax_id))]
# delete tax_id column since the values (if non NA were used to replace staxids)
blast_res <- blast_res %>%
select(-tax_id)
# add taxonomy info
blast_res <- left_join(blast_res, tax_df, by=c("staxids" = "tax_id")) %>%
select(-parent_tax_id, -rank, -name_txt)
i=1
df <- blast_res %>%
filter(qseqid==i)
p <- 6
pidl <- ltg_params_df[p,"pid"]
pcovl <- ltg_params_df[p,"pcov"]
phitl <- ltg_params_df[p,"phit"]
taxnl <- ltg_params_df[p,"taxn"]
seqnl <- ltg_params_df[p,"seqn"]
refresl <- ltg_params_df[p,"refres"]
ltgresl <- ltg_params_df[p,"ltgres"]
# filter the blastres according to  pid, pcov, refres
df_intern <- df %>%
filter(pident>=pidl) %>%
filter(qcovhsp>=pcovl) %>%
filter(taxlevel>=refresl)
# Function to process a row
delete_1_by_row <- function(row, col_number) {
# Remove all occurrences of 1
row <- row[row != 1]
# Create a new row with NA at the end
new_row <- c(row, rep(NA, col_number - length(row)))
return(new_row)
}
get_lineage_ids <- function(taxids, tax_df){
lineages <- as.data.frame(taxids)
colnames(lineages) <- c("tax_id")
# if input is dataframe with blast output
#lineages <- df_intern %>%
#  select(staxids) %>%
#  rename(tax_id=staxids)
i <- 1
while(i < 100){
# use i as name instead of tax_id
new_colname <- as.character(i)
# add parent_tax_id and rename columns
lineages <- left_join(lineages, tax_df, by="tax_id")%>%
select(-rank, -name_txt, -taxlevel) %>%
# !! = interprent the variable
rename(!!new_colname :=tax_id, "tax_id"=parent_tax_id)
i <- i+1
# stop if all lines has the same value (usually 1)
tid_list <- unique(lineages$tax_id)
if(length(tid_list) == 1 && tid_list[1] ==1){
break
}
}
# reverse order of columns
lineages <- lineages[, ncol(lineages):1]
# Apply the function to each row of the lineages data frame:
# delete all 1, shift the remaining elements of each row to the beginning,
# and replace missing values at the end of the row bu NA
lineages <- as.data.frame(t(apply(lineages, 1, delete_1_by_row, ncol(lineages))))
return(lineages)
}
View(df_intern)
# taxids is a vector of taxids; there can be duplicated values
taxids <- df_intern$staxids
tmp <- get_lineage_ids(taxids, tax_df)
View(tmp)
lineages <- get_lineage_ids(taxids, tax_df)
View(lineages)
tmp <- taxids[,i]
i=1
tmp <- taxids[,i]
tmp <- lineages[,i]
tmp
tmp <- as.tibble(lineages[,i])
tmp <- as_tibble(lineages[,i])
tmp
tmp <- as_tibble(lineages[,i]) %>%
group_by()
tmp
tmp <- as_tibble(lineages[,i]) %>%
group_by() %>%
summarize(nhit=count())
tmp <- as_tibble(lineages[,i]) %>%
group_by() %>%
summarize(nhit=length())
tmp <- as_tibble(lineages[,i]) %>%
rename(taxids="")
tmp <- as_tibble(lineages[,i])
tmp
tmp <- as.data.frame(lineages[,i])
tmp
tmp <- as.data.frame(lineages[,i]) %>%
rename(taxids=i)
tmp <- as.data.frame(lineages[,i]) %>%
group_by() %>%
summarize(nhit=length())
tmp <- as.data.frame(lineages[,i])
colnames(tmp) <- c("tax_id")
tmp <- tmp %>%
group_by(tax_id) %>%
summarize(nhit=length(tax_id))
tmp <- as.data.frame(lineages[,i])
colnames(tmp) <- c("tax_id")
tmp <- tmp %>%
group_by(tax_id) %>%
summarize(nhit=length(tax_id)) %>%
arrange(desc(nhit))
# taxids is a vector of taxids; there can be duplicated values
taxids <- df_intern$staxids
phit <- 70
lineages <- get_lineage_ids(taxids, tax_df)
ltg <- NA
for(i in 1:ncol(lineages)){
tmp <- as.data.frame(lineages[,i])
colnames(tmp) <- c("tax_id")
tmp <- tmp %>%
group_by(tax_id) %>%
summarize(nhit=length(tax_id)) %>%
arrange(desc(nhit))
ltg <- tmp[i,tax_id]
if((tmp[1,nhit]/sum(tmp[,nhit])) < phit/100){
ltg <- tmp[i-1,tax_id]
break
}
}
for(i in 1:ncol(lineages)){
tmp <- as.data.frame(lineages[,i])
colnames(tmp) <- c("tax_id")
tmp <- tmp %>%
group_by(tax_id) %>%
summarize(nhit=length(tax_id)) %>%
arrange(desc(nhit))
ltg <- tmp[i,tax_id]
if((tmp[1,"nhit"]/sum(tmp[,"nhit"])) < phit/100){
ltg <- tmp[i-1,"tax_id"]
break
}
}
i = 1
tmp <- as.data.frame(lineages[,i])
colnames(tmp) <- c("tax_id")
tmp <- tmp %>%
group_by(tax_id) %>%
summarize(nhit=length(tax_id)) %>%
arrange(desc(nhit))
ltg <- tmp[i,tax_id]
ltg <- tmp[i,"tax_id"]
ltg
if((tmp[1,"nhit"]/sum(tmp[,"nhit"])) < phit/100){
ltg <- tmp[i-1,"tax_id"]
break
}
# taxids is a vector of taxids; there can be duplicated values
taxids <- df_intern$staxids
phit <- 70
lineages <- get_lineage_ids(taxids, tax_df)
ltg <- NA
for(i in 1:ncol(lineages)){
#    i = 1
tmp <- as.data.frame(lineages[,i])
colnames(tmp) <- c("tax_id")
tmp <- tmp %>%
group_by(tax_id) %>%
summarize(nhit=length(tax_id)) %>%
arrange(desc(nhit))
ltg <- tmp[i,"tax_id"]
if((tmp[1,"nhit"]/sum(tmp[,"nhit"])) < phit/100){
ltg <- tmp[i-1,"tax_id"]
break
}
}
print(ltg)
# taxids is a vector of taxids; there can be duplicated values
taxids <- df_intern$staxids
phit <- 70
lineages <- get_lineage_ids(taxids, tax_df)
ltg <- NA
i = 1
#    i = 1
tmp <- as.data.frame(lineages[,i])
colnames(tmp) <- c("tax_id")
tmp <- tmp %>%
group_by(tax_id) %>%
summarize(nhit=length(tax_id)) %>%
arrange(desc(nhit))
ltg <- tmp[i,"tax_id"]
ltg
tmp[1,"nhit"]
sum(tmp[,"nhit"])
max_hitn <- tmp[1,"nhit"]
max_hitn
max_hitn <- as.numeric(tmp[1,"nhit"])
max_hitn
sum(tmp[,"nhit"])
# taxids is a vector of taxids; there can be duplicated values
taxids <- df_intern$staxids
phit <- 70
lineages <- get_lineage_ids(taxids, tax_df)
ltg <- NA
for(i in 1:ncol(lineages)){
#    i = 1
tmp <- as.data.frame(lineages[,i])
colnames(tmp) <- c("tax_id")
tmp <- tmp %>%
group_by(tax_id) %>%
summarize(nhit=length(tax_id)) %>%
arrange(desc(nhit))
ltg <- tmp[i,"tax_id"]
max_hitn <- as.numeric(tmp[1,"nhit"])
if((max_hitn/sum(tmp[,"nhit"])) < phit/100){
ltg <- tmp[i-1,"tax_id"]
break
}
}
print(ltg)
# taxids is a vector of taxids; there can be duplicated values
taxids <- df_intern$staxids
phit <- 70
lineages <- get_lineage_ids(taxids, tax_df)
ltg <- NA
ltg
i = 1
#    i = 1
tmp <- as.data.frame(lineages[,i])
colnames(tmp) <- c("tax_id")
tmp <- tmp %>%
group_by(tax_id) %>%
summarize(nhit=length(tax_id)) %>%
arrange(desc(nhit))
max_hitn <- as.numeric(tmp[1,"nhit"])
max_hitn
sum(tmp[,"nhit"])
max_hitn/sum(tmp[,"nhit"])
phit/100
# taxids is a vector of taxids; there can be duplicated values
taxids <- df_intern$staxids
phit <- 70
lineages <- get_lineage_ids(taxids, tax_df)
ltg <- NA
for(i in 1:ncol(lineages)){
#    i = 1
tmp <- as.data.frame(lineages[,i])
colnames(tmp) <- c("tax_id")
tmp <- tmp %>%
group_by(tax_id) %>%
summarize(nhit=length(tax_id)) %>%
arrange(desc(nhit))
max_hitn <- as.numeric(tmp[1,"nhit"])
if(max_hitn/sum(tmp[,"nhit"]) < phit/100){
break
}
ltg <- tmp[1,"tax_id"]
}
print(ltg)
# taxids is a vector of taxids; there can be duplicated values
taxids <- df_intern$staxids
phit <- 70
lineages <- get_lineage_ids(taxids, tax_df)
ltg <- NA
for(i in 1:ncol(lineages)){
#    i = 1
tmp <- as.data.frame(lineages[,i])
colnames(tmp) <- c("tax_id")
tmp <- tmp %>%
group_by(tax_id) %>%
summarize(nhit=length(tax_id)) %>%
arrange(desc(nhit))
max_hitn <- as.numeric(tmp[1,"nhit"])
if(max_hitn/sum(tmp[,"nhit"]) < phit/100){
break
}
ltg <- as.numeric(tmp[1,"tax_id"])
}
print(ltg)
make_ltg <- function(taxids, phit=70){
# taxids is a vector of taxids; there can be duplicated values
#  taxids <- df_intern$staxids
#  phit <- 70
lineages <- get_lineage_ids(taxids, tax_df)
ltg <- NA
for(i in 1:ncol(lineages)){
#    i = 1
tmp <- as.data.frame(lineages[,i])
colnames(tmp) <- c("tax_id")
tmp <- tmp %>%
group_by(tax_id) %>%
summarize(nhit=length(tax_id)) %>%
arrange(desc(nhit))
max_hitn <- as.numeric(tmp[1,"nhit"])
if(max_hitn/sum(tmp[,"nhit"]) < phit/100){
break
}
ltg <- as.numeric(tmp[1,"tax_id"])
}
return(ltg)
}
ltg <- make_ltg(df_intern$staxids, phit = phitl)
setwd("~/vtamR")
vsearch_path = ""
blast_path="/home/meglecz/ncbi-blast-2.11.0+/bin/"
taxonomy="/home/meglecz/mkLTG/COInr_for_vtam_2022_05_06_dbV5/COInr_for_vtam_taxonomy.tsv"
blast_db="/home/meglecz/mkLTG/COInr_for_vtam_2022_05_06_dbV5/COInr_for_vtam"
ltg_params_df = data.frame( pid=c(100,97,95,90,85,80),
pcov=c(70,70,70,70,70,70),
phit=c(70,70,70,70,70,70),
taxn=c(1,1,2,3,4,4),
seqn=c(1,1,2,3,4,4),
refres=c("species","species","species","genus","family","family"),
ltgres=c("species","species","species","species", "genus","genus")
)
ltg_params_df = data.frame( pid=c(100,97,95,90,85,80),
pcov=c(70,70,70,70,70,70),
phit=c(70,70,70,70,70,70),
taxn=c(1,1,2,3,4,4),
seqn=c(1,1,2,3,4,4),
refres=c(8,8,8,7,6,6),
ltgres=c(8,8,8,8,7,7)
)
#setwd("D:/vtamR")
# load local packages
load_all(".")
roxygenise() # Builds the help files
usethis::use_roxygen_md() # rebuild the help files ?
fastadir <- "local/mfzr/sorted/"
fileinfo <- "local/user_input/fileinfo_mfzr_eu.csv"
mock_composition <- "local/user_input/mock_composition_mfzr_eu.csv"
sep=";"
# create the output directory and check the the slash at the end
outdir <- check_dir(dir="local/out")
# Measure runtime using system.time()
start_time <- Sys.time()  # Record the start time
# define stat data frame that will be completed with counts after each step
stat_df <- data.frame(parameters=character(),
asv_count=integer(),
read_count=integer(),
sample_count=integer(),
sample_replicate_count=integer())
# read input fasta files in fileinfo, demultiplex and count the number of reads in each plate-sample-replicate
read_count_df <- read_fastas_from_fileinfo(file=fileinfo, dir=fastadir, write_csv=F, outdir=outdir, sep=sep)
# make stat counts
stat_df <- get_stat(read_count_df, stat_df, stage="Input", params=NA)
###
### LFN_global_read_count
###
# Eliminate variants with less than global_read_count_cutoff reads in the dataset
global_read_count_cutoff = 60
read_count_df <- LFN_global_read_count(read_count_df, global_read_count_cutoff, write_csv=T, outdir=outdir, sep=sep)
stat_df <- get_stat(read_count_df, stat_df, stage="LFN_global_read_count", params=global_read_count_cutoff)
###
### PoolReplicates
###
digits = 0
read_count_samples_df <- PoolReplicates(read_count_df, digits=digits, write_csv=T, outdir=outdir, sep=sep)
# create a tmp directory for temporary files using time and a random number
outdir_tmp <- paste(outdir, 'tmp_', trunc(as.numeric(Sys.time())), sample(1:100, 1), sep='')
outdir_tmp <- check_dir(outdir_tmp)
# get unique list of ASVs
# !!!!! TODO Make it possible to use an input file with asv as column => complete file
seqs <- unique(read_count_samples_df$asv)
blast_out <- paste(outdir_tmp, 'blast.out', sep="")
# run blast
run_blast(seqs, blast_db=blast_db, blast_path=blast_path, out=blast_out, qcov_hsp_perc=min(ltg_params_df$pcov), perc_identity=min(ltg_params_df$pid), num_threads=8)
# read taxonomy file; quote="" is important, snce some of the taxon names have quites and this should be ignored
tax_df <- read.delim(taxonomy, header=T, sep="\t", fill=T, quote="")
# make data frame with old taxids as line numbers and taxids in a colums
old_taxid <- tax_df %>%
filter(!is.na(old_tax_id)) %>%
select(tax_id, old_tax_id)
# delete old_tax_ids from tax_df and make taxids unique
tax_df <- tax_df %>%
select(-old_tax_id)
tax_df <- unique(tax_df)
blast_res <- read.delim(blast_out, header=F, sep="\t", fill=T, quote="")
colnames(blast_res) <- c("qseqid","sseqid","pident","length","qcovhsp","staxids","evalue")
blast_res <- blast_res %>%
select(qseqid, pident, qcovhsp, staxids)
# replace old taxids (if any) by up to date ones
blast_res <- left_join(blast_res, old_taxid, by=c("staxids" = "old_tax_id"))
#  blast_res[2, "tax_id"] <- 3333333
blast_res$staxids[which(!is.na(blast_res$tax_id))] <- blast_res$tax_id[which(!is.na(blast_res$tax_id))]
# delete tax_id column since the values (if non NA were used to replace staxids)
blast_res <- blast_res %>%
select(-tax_id)
# add taxonomy info
blast_res <- left_join(blast_res, tax_df, by=c("staxids" = "tax_id")) %>%
select(-parent_tax_id, -rank, -name_txt)
for(i in 1:length(seqs)){ # go through all sequences
#    i=1
df <- blast_res %>%
filter(qseqid==i)
for(p in 1:nrow(ltg_params_df)){ # for each pid
#      p <- 6
pidl <- ltg_params_df[p,"pid"]
pcovl <- ltg_params_df[p,"pcov"]
phitl <- ltg_params_df[p,"phit"]
taxnl <- ltg_params_df[p,"taxn"]
seqnl <- ltg_params_df[p,"seqn"]
refresl <- ltg_params_df[p,"refres"]
ltgresl <- ltg_params_df[p,"ltgres"]
# filter the blastres according to  pid, pcov, refres
df_intern <- df %>%
filter(pident>=pidl) %>%
filter(qcovhsp>=pcovl) %>%
filter(taxlevel>=refresl)
# check if enough taxa and seq among validated hits
tn <- length(unique(df_intern$staxids))
if(tn >= taxnl & nrow(df_intern) > seqnl ){
ltg <- make_ltg(df_intern$staxids, phit = phitl)
print(i)
print(p)
print(ltg)
break
}
}
}
# Function to process a row
delete_1_by_row <- function(row, col_number) {
# Remove all occurrences of 1
row <- row[row != 1]
# Create a new row with NA at the end
new_row <- c(row, rep(NA, col_number - length(row)))
return(new_row)
}
get_lineage_ids <- function(taxids, tax_df){
lineages <- as.data.frame(taxids)
colnames(lineages) <- c("tax_id")
# if input is dataframe with blast output
#lineages <- df_intern %>%
#  select(staxids) %>%
#  rename(tax_id=staxids)
i <- 1
while(i < 100){
# use i as name instead of tax_id
new_colname <- as.character(i)
# add parent_tax_id and rename columns
lineages <- left_join(lineages, tax_df, by="tax_id")%>%
select(-rank, -name_txt, -taxlevel) %>%
# !! = interprent the variable
rename(!!new_colname :=tax_id, "tax_id"=parent_tax_id)
i <- i+1
# stop if all lines has the same value (usually 1)
tid_list <- unique(lineages$tax_id)
if(length(tid_list) == 1 && tid_list[1] ==1){
break
}
}
# reverse order of columns
lineages <- lineages[, ncol(lineages):1]
# Apply the function to each row of the lineages data frame:
# delete all 1, shift the remaining elements of each row to the beginning,
# and replace missing values at the end of the row bu NA
lineages <- as.data.frame(t(apply(lineages, 1, delete_1_by_row, ncol(lineages))))
return(lineages)
}
make_ltg <- function(taxids, phit=70){
# taxids is a vector of taxids; there can be duplicated values
#  taxids <- df_intern$staxids
#  phit <- 70
lineages <- get_lineage_ids(taxids, tax_df)
ltg <- NA
for(i in 1:ncol(lineages)){
#    i = 1
tmp <- as.data.frame(lineages[,i])
colnames(tmp) <- c("tax_id")
tmp <- tmp %>%
group_by(tax_id) %>%
summarize(nhit=length(tax_id)) %>%
arrange(desc(nhit))
max_hitn <- as.numeric(tmp[1,"nhit"])
if(max_hitn/sum(tmp[,"nhit"]) < phit/100){
break
}
ltg <- as.numeric(tmp[1,"tax_id"])
}
return(ltg)
}
for(i in 1:length(seqs)){ # go through all sequences
#    i=1
df <- blast_res %>%
filter(qseqid==i)
for(p in 1:nrow(ltg_params_df)){ # for each pid
#      p <- 6
pidl <- ltg_params_df[p,"pid"]
pcovl <- ltg_params_df[p,"pcov"]
phitl <- ltg_params_df[p,"phit"]
taxnl <- ltg_params_df[p,"taxn"]
seqnl <- ltg_params_df[p,"seqn"]
refresl <- ltg_params_df[p,"refres"]
ltgresl <- ltg_params_df[p,"ltgres"]
# filter the blastres according to  pid, pcov, refres
df_intern <- df %>%
filter(pident>=pidl) %>%
filter(qcovhsp>=pcovl) %>%
filter(taxlevel>=refresl)
# check if enough taxa and seq among validated hits
tn <- length(unique(df_intern$staxids))
if(tn >= taxnl & nrow(df_intern) > seqnl ){
ltg <- make_ltg(df_intern$staxids, phit = phitl)
print(i)
print(p)
print(ltg)
break
}
}
}
View(ltg_params_df)
View(ltg_params_df)
View(ltg_params_df)
View(ltg_params_df)
View(ltg_params_df)
