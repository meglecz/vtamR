tmp$fasta <- NA
for(i in 1:nrow(tmp)){# for each file pairs
# use the name of the fw file and replace extension by fasta
outfile <- sub("\\..*", ".fasta", tmp[i,1])
tmp$fasta[i] <- outfile
outfile <- paste(merged_dir, outfile, sep="")
fw_fastq <- paste(fastqdir, tmp[i,1], sep="")
rv_fastq <- paste(fastqdir, tmp[i,2], sep="")
vsearch <- paste(vsearch_path, "vsearch --fastq_mergepairs ", fw_fastq, " --reverse ", rv_fastq ," --fastaout ",outfile," --fastq_ascii ",fastq_ascii," --fastq_maxdiffs ", fastq_maxdiffs, " --fastq_maxee ", fastq_maxee, " --fastq_minlen ", fastq_minlen, " --fastq_maxlen ",fastq_maxlen, " --fastq_minmergelen ",fastq_minmergelen," --fastq_maxmergelen ",fastq_maxmergelen," --fastq_maxns ", fastq_maxns, " --fastq_truncqual ", fastq_truncqual, " --fastq_minovlen ", fastq_minovlen, sep="")
if(fastq_allowmergestagger){
paste(vsearch, " --fastq_allowmergestagger", sep="")
}
print(vsearch)
system(vsearch)
}
fastainfo_df <- left_join(fastqinfo_df, tmp, by=c("fastq_fw", "fastq_rv"))
View(fastainfo_df)
# read fastqinfo
fastqinfo_df <- read.csv(fastqinfo, header=T, sep=sep)
merged_dir <-paste(outdir, "merged", sep="")
merged_dir<- check_dir(merged_dir)
# get unique list of fastq file pairs
tmp <- fastqinfo_df %>%
select(fastq_fw, fastq_rv)
tmp <- unique(tmp)
tmp$fasta <- NA
for(i in 1:nrow(tmp)){# for each file pairs
# use the name of the fw file and replace extension by fasta
outfile <- sub("\\..*", ".fasta", tmp[i,1])
tmp$fasta[i] <- outfile
outfile <- paste(merged_dir, outfile, sep="")
fw_fastq <- paste(fastqdir, tmp[i,1], sep="")
rv_fastq <- paste(fastqdir, tmp[i,2], sep="")
vsearch <- paste(vsearch_path, "vsearch --fastq_mergepairs ", fw_fastq, " --reverse ", rv_fastq ," --fastaout ",outfile," --fastq_ascii ",fastq_ascii," --fastq_maxdiffs ", fastq_maxdiffs, " --fastq_maxee ", fastq_maxee, " --fastq_minlen ", fastq_minlen, " --fastq_maxlen ",fastq_maxlen, " --fastq_minmergelen ",fastq_minmergelen," --fastq_maxmergelen ",fastq_maxmergelen," --fastq_maxns ", fastq_maxns, " --fastq_truncqual ", fastq_truncqual, " --fastq_minovlen ", fastq_minovlen, sep="")
if(fastq_allowmergestagger){
paste(vsearch, " --fastq_allowmergestagger", sep="")
}
print(vsearch)
system(vsearch)
}
fastainfo_df <- left_join(fastqinfo_df, tmp, by=c("fastq_fw", "fastq_rv"))
# read fastqinfo
fastqinfo_df <- read.csv(fastqinfo, header=T, sep=sep)
merged_dir <-paste(outdir, "merged", sep="")
merged_dir<- check_dir(merged_dir)
# get unique list of fastq file pairs
tmp <- fastqinfo_df %>%
select(fastq_fw, fastq_rv)
tmp <- unique(tmp)
tmp$fasta <- NA
for(i in 1:nrow(tmp)){# for each file pairs
# use the name of the fw file and replace extension by fasta
outfile <- sub("\\..*", ".fasta.gz", tmp[i,1])
tmp$fasta[i] <- outfile
outfile <- paste(merged_dir, outfile, sep="")
fw_fastq <- paste(fastqdir, tmp[i,1], sep="")
rv_fastq <- paste(fastqdir, tmp[i,2], sep="")
vsearch <- paste(vsearch_path, "vsearch --fastq_mergepairs ", fw_fastq, " --reverse ", rv_fastq ," --fastaout ",outfile," --fastq_ascii ",fastq_ascii," --fastq_maxdiffs ", fastq_maxdiffs, " --fastq_maxee ", fastq_maxee, " --fastq_minlen ", fastq_minlen, " --fastq_maxlen ",fastq_maxlen, " --fastq_minmergelen ",fastq_minmergelen," --fastq_maxmergelen ",fastq_maxmergelen," --fastq_maxns ", fastq_maxns, " --fastq_truncqual ", fastq_truncqual, " --fastq_minovlen ", fastq_minovlen, sep="")
if(fastq_allowmergestagger){
paste(vsearch, " --fastq_allowmergestagger", sep="")
}
print(vsearch)
system(vsearch)
}
fastainfo_df <- left_join(fastqinfo_df, tmp, by=c("fastq_fw", "fastq_rv"))
library("utils")
fastainfo_df <- left_join(fastqinfo_df, tmp, by=c("fastq_fw", "fastq_rv")) %>%
select(-fastq_fw, -fastq_rv)
merge <- function(fastqinfo, fastqdir, vsearch_path="", outdir="", fastq_ascii=33, fastq_maxdiffs=10, fastq_maxee=1, fastq_minlen=50, fastq_maxlen=500, fastq_minmergelen=50, fastq_maxmergelen=1000, fastq_maxns=0, fastq_truncqual=10, fastq_minovlen=50, fastq_allowmergestagger=F, sep=","){
# read fastqinfo
fastqinfo_df <- read.csv(fastqinfo, header=T, sep=sep)
merged_dir <-paste(outdir, "merged", sep="")
merged_dir<- check_dir(merged_dir)
# get unique list of fastq file pairs
tmp <- fastqinfo_df %>%
select(fastq_fw, fastq_rv)
tmp <- unique(tmp)
tmp$fasta <- NA
for(i in 1:nrow(tmp)){# for each file pairs
# use the name of the fw file and replace extension by fasta
outfile <- sub("\\..*", ".fasta.gz", tmp[i,1])
tmp$fasta[i] <- outfile
outfile <- paste(merged_dir, outfile, sep="")
fw_fastq <- paste(fastqdir, tmp[i,1], sep="")
rv_fastq <- paste(fastqdir, tmp[i,2], sep="")
vsearch <- paste(vsearch_path, "vsearch --fastq_mergepairs ", fw_fastq, " --reverse ", rv_fastq ," --fastaout ",outfile," --fastq_ascii ",fastq_ascii," --fastq_maxdiffs ", fastq_maxdiffs, " --fastq_maxee ", fastq_maxee, " --fastq_minlen ", fastq_minlen, " --fastq_maxlen ",fastq_maxlen, " --fastq_minmergelen ",fastq_minmergelen," --fastq_maxmergelen ",fastq_maxmergelen," --fastq_maxns ", fastq_maxns, " --fastq_truncqual ", fastq_truncqual, " --fastq_minovlen ", fastq_minovlen, sep="")
if(fastq_allowmergestagger){
paste(vsearch, " --fastq_allowmergestagger", sep="")
}
print(vsearch)
system(vsearch)
}
fastainfo_df <- left_join(fastqinfo_df, tmp, by=c("fastq_fw", "fastq_rv")) %>%
select(-fastq_fw, -fastq_rv)
write.table(fastqinfo_df, file = paste(merged, "fastainfo.csv", sep=""),  row.names = F, sep=sep)
}
merge(fastqinfo=fastqinfo, fastqdir=fastqdir, vsearch_path=vsearch_path, outdir=outdir, fastq_ascii=fastq_ascii, fastq_maxdiffs=fastq_maxdiffs, fastq_maxee=fastq_maxee, fastq_minlen=fastq_minlen, fastq_maxlen=fastq_maxlen, fastq_minmergelen=fastq_minmergelen, fastq_maxmergelen=fastq_maxmergelen, fastq_maxns=fastq_maxns, fastq_truncqual=fastq_truncqual, fastq_minovlen=fastq_minovlen, fastq_allowmergestagger=fastq_allowmergestagger, sep=sep)
merge <- function(fastqinfo, fastqdir, vsearch_path="", outdir="", fastq_ascii=33, fastq_maxdiffs=10, fastq_maxee=1, fastq_minlen=50, fastq_maxlen=500, fastq_minmergelen=50, fastq_maxmergelen=1000, fastq_maxns=0, fastq_truncqual=10, fastq_minovlen=50, fastq_allowmergestagger=F, sep=","){
# read fastqinfo
fastqinfo_df <- read.csv(fastqinfo, header=T, sep=sep)
merged_dir <-paste(outdir, "merged", sep="")
merged_dir<- check_dir(merged_dir)
# get unique list of fastq file pairs
tmp <- fastqinfo_df %>%
select(fastq_fw, fastq_rv)
tmp <- unique(tmp)
tmp$fasta <- NA
for(i in 1:nrow(tmp)){# for each file pairs
# use the name of the fw file and replace extension by fasta
outfile <- sub("\\..*", ".fasta.gz", tmp[i,1])
tmp$fasta[i] <- outfile
outfile <- paste(merged_dir, outfile, sep="")
fw_fastq <- paste(fastqdir, tmp[i,1], sep="")
rv_fastq <- paste(fastqdir, tmp[i,2], sep="")
vsearch <- paste(vsearch_path, "vsearch --fastq_mergepairs ", fw_fastq, " --reverse ", rv_fastq ," --fastaout ",outfile," --fastq_ascii ",fastq_ascii," --fastq_maxdiffs ", fastq_maxdiffs, " --fastq_maxee ", fastq_maxee, " --fastq_minlen ", fastq_minlen, " --fastq_maxlen ",fastq_maxlen, " --fastq_minmergelen ",fastq_minmergelen," --fastq_maxmergelen ",fastq_maxmergelen," --fastq_maxns ", fastq_maxns, " --fastq_truncqual ", fastq_truncqual, " --fastq_minovlen ", fastq_minovlen, sep="")
if(fastq_allowmergestagger){
paste(vsearch, " --fastq_allowmergestagger", sep="")
}
print(vsearch)
system(vsearch)
}
fastainfo_df <- left_join(fastqinfo_df, tmp, by=c("fastq_fw", "fastq_rv")) %>%
select(-fastq_fw, -fastq_rv)
write.table(fastqinfo_df, file = paste(merged_dir, "fastainfo.csv", sep=""),  row.names = F, sep=sep)
}
merge(fastqinfo=fastqinfo, fastqdir=fastqdir, vsearch_path=vsearch_path, outdir=outdir, fastq_ascii=fastq_ascii, fastq_maxdiffs=fastq_maxdiffs, fastq_maxee=fastq_maxee, fastq_minlen=fastq_minlen, fastq_maxlen=fastq_maxlen, fastq_minmergelen=fastq_minmergelen, fastq_maxmergelen=fastq_maxmergelen, fastq_maxns=fastq_maxns, fastq_truncqual=fastq_truncqual, fastq_minovlen=fastq_minovlen, fastq_allowmergestagger=fastq_allowmergestagger, sep=sep)
merge <- function(fastqinfo, fastqdir, vsearch_path="", outdir="", fastq_ascii=33, fastq_maxdiffs=10, fastq_maxee=1, fastq_minlen=50, fastq_maxlen=500, fastq_minmergelen=50, fastq_maxmergelen=1000, fastq_maxns=0, fastq_truncqual=10, fastq_minovlen=50, fastq_allowmergestagger=F, sep=","){
# read fastqinfo
fastqinfo_df <- read.csv(fastqinfo, header=T, sep=sep)
# make aoutput directory
merged_dir <-paste(outdir, "merged", sep="")
merged_dir<- check_dir(merged_dir)
# get unique list of fastq file pairs
tmp <- fastqinfo_df %>%
select(fastq_fw, fastq_rv)
tmp <- unique(tmp)
tmp$fasta <- NA
for(i in 1:nrow(tmp)){# for each file pairs
# use the name of the fw file and replace extension by fasta
outfile <- sub("\\..*", ".fasta.gz", tmp[i,1])
tmp$fasta[i] <- outfile
outfile <- paste(merged_dir, outfile, sep="")
# add path to input filenames
fw_fastq <- paste(fastqdir, tmp[i,1], sep="")
rv_fastq <- paste(fastqdir, tmp[i,2], sep="")
vsearch <- paste(vsearch_path, "vsearch --fastq_mergepairs ", fw_fastq, " --reverse ", rv_fastq ," --fastaout ",outfile," --fastq_ascii ",fastq_ascii," --fastq_maxdiffs ", fastq_maxdiffs, " --fastq_maxee ", fastq_maxee, " --fastq_minlen ", fastq_minlen, " --fastq_maxlen ",fastq_maxlen, " --fastq_minmergelen ",fastq_minmergelen," --fastq_maxmergelen ",fastq_maxmergelen," --fastq_maxns ", fastq_maxns, " --fastq_truncqual ", fastq_truncqual, " --fastq_minovlen ", fastq_minovlen, sep="")
if(fastq_allowmergestagger){ # if reads are longer than the amplicon
paste(vsearch, " --fastq_allowmergestagger", sep="")
}
#    print(vsearch)
system(vsearch)
# Specify the path for the gzipped output file
outfile_gz <- paste(outfile, ".gz", sep="")
# Open the existing uncompressed file for reading
file_content <- readBin(outfile, "raw", file.info(outfile)$size)
# Create a gzipped copy of the file
gz <- gzfile(outfile_gz, "wb")
writeBin(file_content, gz)
close(gz)
}
# make fastinfo file
fastainfo_df <- left_join(fastqinfo_df, tmp, by=c("fastq_fw", "fastq_rv")) %>%
select(-fastq_fw, -fastq_rv)
write.table(fastqinfo_df, file = paste(merged_dir, "fastainfo.csv", sep=""),  row.names = F, sep=sep)
}
merge(fastqinfo=fastqinfo, fastqdir=fastqdir, vsearch_path=vsearch_path, outdir=outdir, fastq_ascii=fastq_ascii, fastq_maxdiffs=fastq_maxdiffs, fastq_maxee=fastq_maxee, fastq_minlen=fastq_minlen, fastq_maxlen=fastq_maxlen, fastq_minmergelen=fastq_minmergelen, fastq_maxmergelen=fastq_maxmergelen, fastq_maxns=fastq_maxns, fastq_truncqual=fastq_truncqual, fastq_minovlen=fastq_minovlen, fastq_allowmergestagger=fastq_allowmergestagger, sep=sep)
merge <- function(fastqinfo, fastqdir, vsearch_path="", outdir="", fastq_ascii=33, fastq_maxdiffs=10, fastq_maxee=1, fastq_minlen=50, fastq_maxlen=500, fastq_minmergelen=50, fastq_maxmergelen=1000, fastq_maxns=0, fastq_truncqual=10, fastq_minovlen=50, fastq_allowmergestagger=F, sep=","){
# read fastqinfo
fastqinfo_df <- read.csv(fastqinfo, header=T, sep=sep)
# make aoutput directory
merged_dir <-paste(outdir, "merged", sep="")
merged_dir<- check_dir(merged_dir)
# get unique list of fastq file pairs
tmp <- fastqinfo_df %>%
select(fastq_fw, fastq_rv)
tmp <- unique(tmp)
tmp$fasta <- NA
for(i in 1:nrow(tmp)){# for each file pairs
# use the name of the fw file and replace extension by fasta
outfile <- sub("\\..*", ".fasta", tmp[i,1])
tmp$fasta[i] <- outfile
outfile <- paste(merged_dir, outfile, sep="")
# add path to input filenames
fw_fastq <- paste(fastqdir, tmp[i,1], sep="")
rv_fastq <- paste(fastqdir, tmp[i,2], sep="")
vsearch <- paste(vsearch_path, "vsearch --fastq_mergepairs ", fw_fastq, " --reverse ", rv_fastq ," --fastaout ",outfile," --fastq_ascii ",fastq_ascii," --fastq_maxdiffs ", fastq_maxdiffs, " --fastq_maxee ", fastq_maxee, " --fastq_minlen ", fastq_minlen, " --fastq_maxlen ",fastq_maxlen, " --fastq_minmergelen ",fastq_minmergelen," --fastq_maxmergelen ",fastq_maxmergelen," --fastq_maxns ", fastq_maxns, " --fastq_truncqual ", fastq_truncqual, " --fastq_minovlen ", fastq_minovlen, sep="")
if(fastq_allowmergestagger){ # if reads are longer than the amplicon
paste(vsearch, " --fastq_allowmergestagger", sep="")
}
#    print(vsearch)
system(vsearch)
# Specify the path for the gzipped output file
outfile_gz <- paste(outfile, ".gz", sep="")
# Open the existing uncompressed file for reading
file_content <- readBin(outfile, "raw", file.info(outfile)$size)
# Create a gzipped copy of the file
gz <- gzfile(outfile_gz, "wb")
writeBin(file_content, gz)
close(gz)
#    rm(outfile)
}
# make fastinfo file
fastainfo_df <- left_join(fastqinfo_df, tmp, by=c("fastq_fw", "fastq_rv")) %>%
select(-fastq_fw, -fastq_rv)
write.table(fastqinfo_df, file = paste(merged_dir, "fastainfo.csv", sep=""),  row.names = F, sep=sep)
}
merge(fastqinfo=fastqinfo, fastqdir=fastqdir, vsearch_path=vsearch_path, outdir=outdir, fastq_ascii=fastq_ascii, fastq_maxdiffs=fastq_maxdiffs, fastq_maxee=fastq_maxee, fastq_minlen=fastq_minlen, fastq_maxlen=fastq_maxlen, fastq_minmergelen=fastq_minmergelen, fastq_maxmergelen=fastq_maxmergelen, fastq_maxns=fastq_maxns, fastq_truncqual=fastq_truncqual, fastq_minovlen=fastq_minovlen, fastq_allowmergestagger=fastq_allowmergestagger, sep=sep)
merge <- function(fastqinfo, fastqdir, vsearch_path="", outdir="", fastq_ascii=33, fastq_maxdiffs=10, fastq_maxee=1, fastq_minlen=50, fastq_maxlen=500, fastq_minmergelen=50, fastq_maxmergelen=1000, fastq_maxns=0, fastq_truncqual=10, fastq_minovlen=50, fastq_allowmergestagger=F, sep=","){
# read fastqinfo
fastqinfo_df <- read.csv(fastqinfo, header=T, sep=sep)
# make aoutput directory
merged_dir <-paste(outdir, "merged", sep="")
merged_dir<- check_dir(merged_dir)
# get unique list of fastq file pairs
tmp <- fastqinfo_df %>%
select(fastq_fw, fastq_rv)
tmp <- unique(tmp)
tmp$fasta <- NA
for(i in 1:nrow(tmp)){# for each file pairs
# use the name of the fw file and replace extension by fasta
outfile <- sub("\\..*", ".fasta", tmp[i,1])
tmp$fasta[i] <- outfile
outfile <- paste(merged_dir, outfile, sep="")
# add path to input filenames
fw_fastq <- paste(fastqdir, tmp[i,1], sep="")
rv_fastq <- paste(fastqdir, tmp[i,2], sep="")
vsearch <- paste(vsearch_path, "vsearch --fastq_mergepairs ", fw_fastq, " --reverse ", rv_fastq ," --fastaout ",outfile," --fastq_ascii ",fastq_ascii," --fastq_maxdiffs ", fastq_maxdiffs, " --fastq_maxee ", fastq_maxee, " --fastq_minlen ", fastq_minlen, " --fastq_maxlen ",fastq_maxlen, " --fastq_minmergelen ",fastq_minmergelen," --fastq_maxmergelen ",fastq_maxmergelen," --fastq_maxns ", fastq_maxns, " --fastq_truncqual ", fastq_truncqual, " --fastq_minovlen ", fastq_minovlen, sep="")
if(fastq_allowmergestagger){ # if reads are longer than the amplicon
paste(vsearch, " --fastq_allowmergestagger", sep="")
}
#    print(vsearch)
system(vsearch)
# Specify the path for the gzipped output file
outfile_gz <- paste(outfile, ".gz", sep="")
# Open the existing uncompressed file for reading
file_content <- readBin(outfile, "raw", file.info(outfile)$size)
# Create a gzipped copy of the file
gz <- gzfile(outfile_gz, "wb")
writeBin(file_content, gz)
close(gz)
file.remove(outfile)
}
# make fastinfo file
fastainfo_df <- left_join(fastqinfo_df, tmp, by=c("fastq_fw", "fastq_rv")) %>%
select(-fastq_fw, -fastq_rv)
write.table(fastqinfo_df, file = paste(merged_dir, "fastainfo.csv", sep=""),  row.names = F, sep=sep)
}
merge(fastqinfo=fastqinfo, fastqdir=fastqdir, vsearch_path=vsearch_path, outdir=outdir, fastq_ascii=fastq_ascii, fastq_maxdiffs=fastq_maxdiffs, fastq_maxee=fastq_maxee, fastq_minlen=fastq_minlen, fastq_maxlen=fastq_maxlen, fastq_minmergelen=fastq_minmergelen, fastq_maxmergelen=fastq_maxmergelen, fastq_maxns=fastq_maxns, fastq_truncqual=fastq_truncqual, fastq_minovlen=fastq_minovlen, fastq_allowmergestagger=fastq_allowmergestagger, sep=sep)
merge <- function(fastqinfo, fastqdir, vsearch_path="", outdir="", fastq_ascii=33, fastq_maxdiffs=10, fastq_maxee=1, fastq_minlen=50, fastq_maxlen=500, fastq_minmergelen=50, fastq_maxmergelen=1000, fastq_maxns=0, fastq_truncqual=10, fastq_minovlen=50, fastq_allowmergestagger=F, sep=","){
# read fastqinfo
fastqinfo_df <- read.csv(fastqinfo, header=T, sep=sep)
# make aoutput directory
merged_dir <-paste(outdir, "merged", sep="")
merged_dir<- check_dir(merged_dir)
# get unique list of fastq file pairs
tmp <- fastqinfo_df %>%
select(fastq_fw, fastq_rv)
tmp <- unique(tmp)
tmp$fasta <- NA
for(i in 1:nrow(tmp)){# for each file pairs
# use the name of the fw file and replace extension by fasta
outfile <- sub("\\..*", ".fasta", tmp[i,1])
tmp$fasta[i] <- outfile
outfile <- paste(merged_dir, outfile, sep="")
# add path to input filenames
fw_fastq <- paste(fastqdir, tmp[i,1], sep="")
rv_fastq <- paste(fastqdir, tmp[i,2], sep="")
vsearch <- paste(vsearch_path, "vsearch --fastq_mergepairs ", fw_fastq, " --reverse ", rv_fastq ," --fastaout ",outfile," --quiet --fastq_ascii ",fastq_ascii," --fastq_maxdiffs ", fastq_maxdiffs, " --fastq_maxee ", fastq_maxee, " --fastq_minlen ", fastq_minlen, " --fastq_maxlen ",fastq_maxlen, " --fastq_minmergelen ",fastq_minmergelen," --fastq_maxmergelen ",fastq_maxmergelen," --fastq_maxns ", fastq_maxns, " --fastq_truncqual ", fastq_truncqual, " --fastq_minovlen ", fastq_minovlen, sep="")
if(fastq_allowmergestagger){ # if reads are longer than the amplicon
paste(vsearch, " --fastq_allowmergestagger", sep="")
}
#    print(vsearch)
system(vsearch)
# Specify the path for the gzipped output file
outfile_gz <- paste(outfile, ".gz", sep="")
# Open the existing uncompressed file for reading
file_content <- readBin(outfile, "raw", file.info(outfile)$size)
# Create a gzipped copy of the file
gz <- gzfile(outfile_gz, "wb")
writeBin(file_content, gz)
close(gz)
file.remove(outfile)
}
# make fastinfo file
fastainfo_df <- left_join(fastqinfo_df, tmp, by=c("fastq_fw", "fastq_rv")) %>%
select(-fastq_fw, -fastq_rv)
write.table(fastainfo_df, file = paste(merged_dir, "fastainfo.csv", sep=""),  row.names = F, sep=sep)
}
merge(fastqinfo=fastqinfo, fastqdir=fastqdir, vsearch_path=vsearch_path, outdir=outdir, fastq_ascii=fastq_ascii, fastq_maxdiffs=fastq_maxdiffs, fastq_maxee=fastq_maxee, fastq_minlen=fastq_minlen, fastq_maxlen=fastq_maxlen, fastq_minmergelen=fastq_minmergelen, fastq_maxmergelen=fastq_maxmergelen, fastq_maxns=fastq_maxns, fastq_truncqual=fastq_truncqual, fastq_minovlen=fastq_minovlen, fastq_allowmergestagger=fastq_allowmergestagger, sep=sep)
compress="gz"
merge <- function(fastqinfo, fastqdir, vsearch_path="", outdir="", fastq_ascii=33, fastq_maxdiffs=10, fastq_maxee=1, fastq_minlen=50, fastq_maxlen=500, fastq_minmergelen=50, fastq_maxmergelen=1000, fastq_maxns=0, fastq_truncqual=10, fastq_minovlen=50, fastq_allowmergestagger=F, sep=",", compress=0){
# read fastqinfo
fastqinfo_df <- read.csv(fastqinfo, header=T, sep=sep)
# make aoutput directory
merged_dir <-paste(outdir, "merged", sep="")
merged_dir<- check_dir(merged_dir)
# get unique list of fastq file pairs
tmp <- fastqinfo_df %>%
select(fastq_fw, fastq_rv)
tmp <- unique(tmp)
tmp$fasta <- NA
for(i in 1:nrow(tmp)){# for each file pairs
# use the name of the fw file and replace extension by fasta
outfile <- sub("\\..*", ".fasta", tmp[i,1])
tmp$fasta[i] <- outfile
outfile <- paste(merged_dir, outfile, sep="")
# add path to input filenames
fw_fastq <- paste(fastqdir, tmp[i,1], sep="")
rv_fastq <- paste(fastqdir, tmp[i,2], sep="")
vsearch <- paste(vsearch_path, "vsearch --fastq_mergepairs ", fw_fastq, " --reverse ", rv_fastq ," --fastaout ",outfile," --quiet --fastq_ascii ",fastq_ascii," --fastq_maxdiffs ", fastq_maxdiffs, " --fastq_maxee ", fastq_maxee, " --fastq_minlen ", fastq_minlen, " --fastq_maxlen ",fastq_maxlen, " --fastq_minmergelen ",fastq_minmergelen," --fastq_maxmergelen ",fastq_maxmergelen," --fastq_maxns ", fastq_maxns, " --fastq_truncqual ", fastq_truncqual, " --fastq_minovlen ", fastq_minovlen, sep="")
if(fastq_allowmergestagger){ # if reads are longer than the amplicon
paste(vsearch, " --fastq_allowmergestagger", sep="")
}
#    print(vsearch)
system(vsearch)
if(compress == "gz"){
# Specify the path for the gzipped output file
outfile_gz <- paste(outfile, ".gz", sep="")
# Open the existing uncompressed file for reading
file_content <- readBin(outfile, "raw", file.info(outfile)$size)
# Create a gzipped copy of the file
gz <- gzfile(outfile_gz, "wb")
writeBin(file_content, gz)
close(gz)
file.remove(outfile)
tmp$fasta[i] <- outfile_gz
}
if(compress == "zip"){
outfile_zip <- paste(outfile, ".zip", sep="")
zip(outfile_zip, outfile)
tmp$fasta[i] <- outfile_zip
}
}
# make fastinfo file
fastainfo_df <- left_join(fastqinfo_df, tmp, by=c("fastq_fw", "fastq_rv")) %>%
select(-fastq_fw, -fastq_rv)
write.table(fastainfo_df, file = paste(merged_dir, "fastainfo.csv", sep=""),  row.names = F, sep=sep)
}
merge(fastqinfo=fastqinfo, fastqdir=fastqdir, vsearch_path=vsearch_path, outdir=outdir, fastq_ascii=fastq_ascii, fastq_maxdiffs=fastq_maxdiffs, fastq_maxee=fastq_maxee, fastq_minlen=fastq_minlen, fastq_maxlen=fastq_maxlen, fastq_minmergelen=fastq_minmergelen, fastq_maxmergelen=fastq_maxmergelen, fastq_maxns=fastq_maxns, fastq_truncqual=fastq_truncqual, fastq_minovlen=fastq_minovlen, fastq_allowmergestagger=fastq_allowmergestagger, sep=sep, compress=compress)
merge <- function(fastqinfo, fastqdir, vsearch_path="", outdir="", fastq_ascii=33, fastq_maxdiffs=10, fastq_maxee=1, fastq_minlen=50, fastq_maxlen=500, fastq_minmergelen=50, fastq_maxmergelen=1000, fastq_maxns=0, fastq_truncqual=10, fastq_minovlen=50, fastq_allowmergestagger=F, sep=",", compress=0){
# read fastqinfo
fastqinfo_df <- read.csv(fastqinfo, header=T, sep=sep)
# make aoutput directory
merged_dir <-paste(outdir, "merged", sep="")
merged_dir<- check_dir(merged_dir)
# get unique list of fastq file pairs
tmp <- fastqinfo_df %>%
select(fastq_fw, fastq_rv)
tmp <- unique(tmp)
tmp$fasta <- NA
for(i in 1:nrow(tmp)){# for each file pairs
# use the name of the fw file and replace extension by fasta
outfile <- sub("\\..*", ".fasta", tmp[i,1])
tmp$fasta[i] <- outfile
outfile <- paste(merged_dir, outfile, sep="")
# add path to input filenames
fw_fastq <- paste(fastqdir, tmp[i,1], sep="")
rv_fastq <- paste(fastqdir, tmp[i,2], sep="")
vsearch <- paste(vsearch_path, "vsearch --fastq_mergepairs ", fw_fastq, " --reverse ", rv_fastq ," --fastaout ",outfile," --quiet --fastq_ascii ",fastq_ascii," --fastq_maxdiffs ", fastq_maxdiffs, " --fastq_maxee ", fastq_maxee, " --fastq_minlen ", fastq_minlen, " --fastq_maxlen ",fastq_maxlen, " --fastq_minmergelen ",fastq_minmergelen," --fastq_maxmergelen ",fastq_maxmergelen," --fastq_maxns ", fastq_maxns, " --fastq_truncqual ", fastq_truncqual, " --fastq_minovlen ", fastq_minovlen, sep="")
if(fastq_allowmergestagger){ # if reads are longer than the amplicon
paste(vsearch, " --fastq_allowmergestagger", sep="")
}
#    print(vsearch)
system(vsearch)
if(compress == "gz"){
# Specify the path for the gzipped output file
outfile_gz <- paste(outfile, ".gz", sep="")
# Open the existing uncompressed file for reading
file_content <- readBin(outfile, "raw", file.info(outfile)$size)
# Create a gzipped copy of the file
gz <- gzfile(outfile_gz, "wb")
writeBin(file_content, gz)
close(gz)
file.remove(outfile)
tmp$fasta[i] <- paste(tmp$fasta[i], ".gz", sep="")
}
if(compress == "zip"){
outfile_zip <- paste(outfile, ".zip", sep="")
zip(outfile_zip, outfile)
tmp$fasta[i] <- paste(tmp$fasta[i], ".zip", sep="")
}
}
# make fastinfo file
fastainfo_df <- left_join(fastqinfo_df, tmp, by=c("fastq_fw", "fastq_rv")) %>%
select(-fastq_fw, -fastq_rv)
write.table(fastainfo_df, file = paste(merged_dir, "fastainfo.csv", sep=""),  row.names = F, sep=sep)
}
merge(fastqinfo=fastqinfo, fastqdir=fastqdir, vsearch_path=vsearch_path, outdir=outdir, fastq_ascii=fastq_ascii, fastq_maxdiffs=fastq_maxdiffs, fastq_maxee=fastq_maxee, fastq_minlen=fastq_minlen, fastq_maxlen=fastq_maxlen, fastq_minmergelen=fastq_minmergelen, fastq_maxmergelen=fastq_maxmergelen, fastq_maxns=fastq_maxns, fastq_truncqual=fastq_truncqual, fastq_minovlen=fastq_minovlen, fastq_allowmergestagger=fastq_allowmergestagger, sep=sep, compress=compress)
compress="zip"
merge(fastqinfo=fastqinfo, fastqdir=fastqdir, vsearch_path=vsearch_path, outdir=outdir, fastq_ascii=fastq_ascii, fastq_maxdiffs=fastq_maxdiffs, fastq_maxee=fastq_maxee, fastq_minlen=fastq_minlen, fastq_maxlen=fastq_maxlen, fastq_minmergelen=fastq_minmergelen, fastq_maxmergelen=fastq_maxmergelen, fastq_maxns=fastq_maxns, fastq_truncqual=fastq_truncqual, fastq_minovlen=fastq_minovlen, fastq_allowmergestagger=fastq_allowmergestagger, sep=sep, compress=compress)
compress=0
merge(fastqinfo=fastqinfo, fastqdir=fastqdir, vsearch_path=vsearch_path, outdir=outdir, fastq_ascii=fastq_ascii, fastq_maxdiffs=fastq_maxdiffs, fastq_maxee=fastq_maxee, fastq_minlen=fastq_minlen, fastq_maxlen=fastq_maxlen, fastq_minmergelen=fastq_minmergelen, fastq_maxmergelen=fastq_maxmergelen, fastq_maxns=fastq_maxns, fastq_truncqual=fastq_truncqual, fastq_minovlen=fastq_minovlen, fastq_allowmergestagger=fastq_allowmergestagger, sep=sep, compress=compress)
colnames(fastqinfo)
colnames(fastqinfo_df)
setwd("~/vtamR")
vsearch_path = ""
blast_path="~/ncbi-blast-2.11.0+/bin/" # bombyx
#blast_path="" # endoume deactivate conda
#db_path="~/mkCOInr/COInr/COInr_for_vtam_2023_05_03_dbV5/" # Endoume
db_path="~/mkLTG/COInr_for_vtam_2022_05_06_dbV5/" # Bombyx
taxonomy=paste(db_path, "COInr_for_vtam_taxonomy.tsv", sep="")
blast_db=paste(db_path, "COInr_for_vtam", sep="")
ltg_params_df = data.frame( pid=c(100,97,95,90,85,80),
pcov=c(70,70,70,70,70,70),
phit=c(70,70,70,70,70,70),
taxn=c(1,1,2,3,4,4),
seqn=c(1,1,2,3,4,4),
refres=c("species","species","species","genus","family","family"),
ltgres=c("species","species","species","species", "genus","genus")
)
ltg_params_df = data.frame( pid=c(100,97,95,90,85,80),
pcov=c(70,70,70,70,70,70),
phit=c(70,70,70,70,70,70),
taxn=c(1,1,2,3,4,4),
seqn=c(1,1,2,3,4,4),
refres=c(8,8,8,7,6,6),
ltgres=c(8,8,8,8,7,7)
)
#setwd("D:/vtamR")
# load local packages
load_all(".")
roxygenise() # Builds the help files
usethis::use_roxygen_md() # rebuild the help files ?
fastqdir <- "/home/meglecz/vtam_test/example/fastq/"
fastqinfo <- "local/user_input/fastqinfo_mfzr_eu.csv"
fastadir <- "local/mfzr/sorted/"
fileinfo <- "local/user_input/fileinfo_mfzr_eu.csv"
mock_composition <- "local/user_input/mock_composition_mfzr_eu.csv"
sep=";"
# create the output directory and check the the slash at the end
outdir <- check_dir(dir="local/out")
# Measure runtime using system.time()
start_time <- Sys.time()  # Record the start time
# define stat data frame that will be completed with counts after each step
stat_df <- data.frame(parameters=character(),
asv_count=integer(),
read_count=integer(),
sample_count=integer(),
sample_replicate_count=integer())
fastq_ascii <- 33
fastq_maxdiffs <- 10
fastq_maxee <- 1
fastq_minlen <- 50
fastq_maxlen <- 500
fastq_minmergelen <- 50
fastq_maxmergelen <-500
fastq_maxns <- 0
fastq_truncqual <- 10
fastq_minovlen <- 50
fastq_allowmergestagger <- F
compress=0 # "gz" or "zip" for compressing output files; no comprssion by default
merge(fastqinfo=fastqinfo, fastqdir=fastqdir, vsearch_path=vsearch_path, outdir=outdir, fastq_ascii=fastq_ascii, fastq_maxdiffs=fastq_maxdiffs, fastq_maxee=fastq_maxee, fastq_minlen=fastq_minlen, fastq_maxlen=fastq_maxlen, fastq_minmergelen=fastq_minmergelen, fastq_maxmergelen=fastq_maxmergelen, fastq_maxns=fastq_maxns, fastq_truncqual=fastq_truncqual, fastq_minovlen=fastq_minovlen, fastq_allowmergestagger=fastq_allowmergestagger, sep=sep, compress=compress)
setwd("~/vtamR")
vsearch_path = ""
blast_path="~/ncbi-blast-2.11.0+/bin/" # bombyx
#blast_path="" # endoume deactivate conda
#db_path="~/mkCOInr/COInr/COInr_for_vtam_2023_05_03_dbV5/" # Endoume
db_path="~/mkLTG/COInr_for_vtam_2022_05_06_dbV5/" # Bombyx
taxonomy=paste(db_path, "COInr_for_vtam_taxonomy.tsv", sep="")
blast_db=paste(db_path, "COInr_for_vtam", sep="")
ltg_params_df = data.frame( pid=c(100,97,95,90,85,80),
pcov=c(70,70,70,70,70,70),
phit=c(70,70,70,70,70,70),
taxn=c(1,1,2,3,4,4),
seqn=c(1,1,2,3,4,4),
refres=c("species","species","species","genus","family","family"),
ltgres=c("species","species","species","species", "genus","genus")
)
ltg_params_df = data.frame( pid=c(100,97,95,90,85,80),
pcov=c(70,70,70,70,70,70),
phit=c(70,70,70,70,70,70),
taxn=c(1,1,2,3,4,4),
seqn=c(1,1,2,3,4,4),
refres=c(8,8,8,7,6,6),
ltgres=c(8,8,8,8,7,7)
)
#setwd("D:/vtamR")
# load local packages
load_all(".")
roxygenise() # Builds the help files
usethis::use_roxygen_md() # rebuild the help files ?
fastqdir <- "/home/meglecz/vtam_test/example/fastq/"
fastqinfo <- "local/user_input/fastqinfo_mfzr_eu.csv"
fastadir <- "local/mfzr/sorted/"
fileinfo <- "local/user_input/fileinfo_mfzr_eu.csv"
mock_composition <- "local/user_input/mock_composition_mfzr_eu.csv"
sep=";"
# create the output directory and check the the slash at the end
outdir <- check_dir(dir="local/out")
# Measure runtime using system.time()
start_time <- Sys.time()  # Record the start time
# define stat data frame that will be completed with counts after each step
stat_df <- data.frame(parameters=character(),
asv_count=integer(),
read_count=integer(),
sample_count=integer(),
sample_replicate_count=integer())
fastq_ascii <- 33
fastq_maxdiffs <- 10
fastq_maxee <- 1
fastq_minlen <- 50
fastq_maxlen <- 500
fastq_minmergelen <- 50
fastq_maxmergelen <-500
fastq_maxns <- 0
fastq_truncqual <- 10
fastq_minovlen <- 50
fastq_allowmergestagger <- F
compress=0 # "gz" or "zip" for compressing output files; no comprssion by default
fastainfo_df <- merge(fastqinfo=fastqinfo, fastqdir=fastqdir, vsearch_path=vsearch_path, outdir=outdir, fastq_ascii=fastq_ascii, fastq_maxdiffs=fastq_maxdiffs, fastq_maxee=fastq_maxee, fastq_minlen=fastq_minlen, fastq_maxlen=fastq_maxlen, fastq_minmergelen=fastq_minmergelen, fastq_maxmergelen=fastq_maxmergelen, fastq_maxns=fastq_maxns, fastq_truncqual=fastq_truncqual, fastq_minovlen=fastq_minovlen, fastq_allowmergestagger=fastq_allowmergestagger, sep=sep, compress=compress)
View(fastainfo_df)
merge(fastqinfo=fastqinfo, fastqdir=fastqdir, vsearch_path=vsearch_path, outdir=outdir, fastq_ascii=fastq_ascii, fastq_maxdiffs=fastq_maxdiffs, fastq_maxee=fastq_maxee, fastq_minlen=fastq_minlen, fastq_maxlen=fastq_maxlen, fastq_minmergelen=fastq_minmergelen, fastq_maxmergelen=fastq_maxmergelen, fastq_maxns=fastq_maxns, fastq_truncqual=fastq_truncqual, fastq_minovlen=fastq_minovlen, fastq_allowmergestagger=fastq_allowmergestagger, sep=sep, compress=compress)
