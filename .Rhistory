#'                                       vsearch_path="vsearch",
#'                                       swarm_path="swarm",
#'                                       num_threads=8,
#'                                       outfile="density_plot.png")
#' }
#' @export
PairwiseIdentityPlotPerSwarmD <- function(read_count,
swarm_d_min=1,
swarm_d_max=15,
swarm_d_increment=1,
min_id = 0.8,
vsearch_path="vsearch",
swarm_path="swarm",
num_threads=0,
outfile="",
sep=",",
quiet=TRUE
){
##### make df if read_count is file
if(is.character(read_count)){
read_count_df <- read.csv(read_count, header=T, sep=sep)
}else{
read_count_df <- read_count
}
#####
# make pairwise_id df with query, target, identity
pairwise_id <- PairwiseIdentity(read_count_df, min_id = 0.8, vsearch_path=vsearch_path, quiet=TRUE, num_threads=0)
#####
# make a df with unique asv, asv_id and readcount (sum)
asv_df <- read_count_df %>%
group_by(asv, asv_id) %>%
summarize(rc = sum(read_count), .groups="drop")
#####
# make a fasta file with unique asv format adapted to swarm
input_swarm <- file.path(tempdir(), "swarm_input.fasta")
writeLines(paste(">", asv_df$asv_id, "_",
asv_df$rc, "\n",
asv_df$asv,
sep=""),
input_swarm)
#####
# initialize data frame (cluster: same/different)
pairwise_id_d <- data.frame(identity = numeric(),
cluster = character(),
swarm_d= factor())
#####
# for each d
for(d in seq(swarm_d_min, swarm_d_max, by=swarm_d_increment)){
print(d)
#####
# run swarm
# make tmp dir separatelit for each d
tmp_dir <-paste('tmp_swarm_', d, '_', trunc(as.numeric(Sys.time())), sample(1:100, 1), sep='')
tmp_dir <- file.path(tempdir(), tmp_dir)
check_dir(tmp_dir)
# clusters.txt each line is a cluster, with asv_ids separated  by space
clusters <- file.path(tmp_dir, "clusters.txt")
swarm <- paste(swarm_path, " -d ", d, " -o ", clusters, sep="")
if(num_threads > 0){ # if num_threads have been specified
swarm <- paste(swarm, " -t ", num_threads, sep="")
}
swarm <- paste(swarm, input_swarm, sep=" ")
if(!quiet){
print(swarm)
}
system(swarm)
#####
# make a data frame with cluster_id and asv_id columns,
# where asv_id has all swarm input asv_id,
# and  cluster_id is the name of the cluster they belong to
# read.table is unpredictable. Use a more complicated, but more sure solution.
# Read the file line by line
lines <- readLines(clusters)
# Split each line by whitespace
split_lines <- strsplit(lines, "[[:space:]]+")
# Determine the maximum number of fields
max_cols <- max(sapply(split_lines, length))
# Convert to a data frame and fill empty cells by NA
#    cluster_df <- as.data.frame(do.call(rbind, lapply(split_lines, function(x) c(x, rep(NA, max_cols - length(x))))),
#                                stringsAsFactors = FALSE)
cluster_df <- as.data.frame(
do.call(
rbind, lapply(
split_lines,
function(x) c(x, rep(NA, max_cols - length(x)))
)
),
stringsAsFactors = FALSE
)
#  repeat each cluster_id as many times as columns
# transpose and flatten to make asv_id
# This will produce some lines with NA for asv_id. Filter them out afterwards.
cluster_df <- data.frame(cluster_id = rep(cluster_df$V1,
each = ncol(cluster_df)),
asv_id = as.vector(t(cluster_df[,])))
# delete lines with NA values in asv_id
cluster_df <- cluster_df %>%
filter(!is.na(asv_id))
# delete read_counts from id
cluster_df$cluster_id <- as.numeric(
sub("_[0-9]+", "", cluster_df$cluster_id ))
cluster_df$asv_id <- as.numeric(
sub("_[0-9]+", "", cluster_df$asv_id ))
#####
# add to pairwise_id the clusters of each query and target and define
# if they are in the same or different clusters
pairwise_id_local <- left_join(pairwise_id, cluster_df, by=c("query"="asv_id")) %>%
rename(cluster_id_query = cluster_id)
pairwise_id_local <- left_join(pairwise_id_local, cluster_df, by=c("target"="asv_id")) %>%
rename(cluster_id_target = cluster_id)
# add within/between column, and the d for each line
pairwise_id_local <- pairwise_id_local %>%
mutate(cluster = ifelse(cluster_id_query == cluster_id_target, "same", "different")) %>%
mutate(swarm_d=paste0("swarm's d: ",d)) %>%
select(identity, cluster, swarm_d)
# add lines to the oveall df
pairwise_id_d <- rbind(pairwise_id_d, pairwise_id_local)
}
PairwiseIdentityPlotPerSwarmD <- function(read_count,
swarm_d_min=1,
swarm_d_max=15,
swarm_d_increment=1,
min_id = 0.8,
vsearch_path="vsearch",
swarm_path="swarm",
num_threads=0,
outfile="",
sep=",",
quiet=TRUE
){
##### make df if read_count is file
if(is.character(read_count)){
read_count_df <- read.csv(read_count, header=T, sep=sep)
}else{
read_count_df <- read_count
}
#####
# make pairwise_id df with query, target, identity
pairwise_id <- PairwiseIdentity(read_count_df, min_id = 0.8, vsearch_path=vsearch_path, quiet=TRUE, num_threads=0)
#####
# make a df with unique asv, asv_id and readcount (sum)
asv_df <- read_count_df %>%
group_by(asv, asv_id) %>%
summarize(rc = sum(read_count), .groups="drop")
#####
# make a fasta file with unique asv format adapted to swarm
input_swarm <- file.path(tempdir(), "swarm_input.fasta")
writeLines(paste(">", asv_df$asv_id, "_",
asv_df$rc, "\n",
asv_df$asv,
sep=""),
input_swarm)
#####
# initialize data frame (cluster: same/different)
pairwise_id_d <- data.frame(identity = numeric(),
cluster = character(),
swarm_d= factor())
#####
# for each d
for(d in seq(swarm_d_min, swarm_d_max, by=swarm_d_increment)){
print(d)
#####
# run swarm
# make tmp dir separatelit for each d
tmp_dir <-paste('tmp_swarm_', d, '_', trunc(as.numeric(Sys.time())), sample(1:100, 1), sep='')
tmp_dir <- file.path(tempdir(), tmp_dir)
check_dir(tmp_dir)
# clusters.txt each line is a cluster, with asv_ids separated  by space
clusters <- file.path(tmp_dir, "clusters.txt")
swarm <- paste(swarm_path, " -d ", d, " -o ", clusters, sep="")
if(num_threads > 0){ # if num_threads have been specified
swarm <- paste(swarm, " -t ", num_threads, sep="")
}
swarm <- paste(swarm, input_swarm, sep=" ")
if(!quiet){
print(swarm)
}
system(swarm)
#####
# make a data frame with cluster_id and asv_id columns,
# where asv_id has all swarm input asv_id,
# and  cluster_id is the name of the cluster they belong to
# read.table is unpredictable. Use a more complicated, but more sure solution.
# Read the file line by line
lines <- readLines(clusters)
# Split each line by whitespace
split_lines <- strsplit(lines, "[[:space:]]+")
# Determine the maximum number of fields
max_cols <- max(sapply(split_lines, length))
# Convert to a data frame and fill empty cells by NA
#    cluster_df <- as.data.frame(do.call(rbind, lapply(split_lines, function(x) c(x, rep(NA, max_cols - length(x))))),
#                                stringsAsFactors = FALSE)
cluster_df <- as.data.frame(
do.call(
rbind, lapply(
split_lines,
function(x) c(x, rep(NA, max_cols - length(x)))
)
),
stringsAsFactors = FALSE
)
#  repeat each cluster_id as many times as columns
# transpose and flatten to make asv_id
# This will produce some lines with NA for asv_id. Filter them out afterwards.
cluster_df <- data.frame(cluster_id = rep(cluster_df$V1,
each = ncol(cluster_df)),
asv_id = as.vector(t(cluster_df[,])))
# delete lines with NA values in asv_id
cluster_df <- cluster_df %>%
filter(!is.na(asv_id))
# delete read_counts from id
cluster_df$cluster_id <- as.numeric(
sub("_[0-9]+", "", cluster_df$cluster_id ))
cluster_df$asv_id <- as.numeric(
sub("_[0-9]+", "", cluster_df$asv_id ))
#####
# add to pairwise_id the clusters of each query and target and define
# if they are in the same or different clusters
pairwise_id_local <- left_join(pairwise_id, cluster_df, by=c("query"="asv_id")) %>%
rename(cluster_id_query = cluster_id)
pairwise_id_local <- left_join(pairwise_id_local, cluster_df, by=c("target"="asv_id")) %>%
rename(cluster_id_target = cluster_id)
# add within/between column, and the d for each line
pairwise_id_local <- pairwise_id_local %>%
mutate(cluster = ifelse(cluster_id_query == cluster_id_target, "same", "different")) %>%
mutate(swarm_d=paste0("swarm's d: ",d)) %>%
select(identity, cluster, swarm_d)
# add lines to the oveall df
pairwise_id_d <- rbind(pairwise_id_d, pairwise_id_local)
} # end for
bad_rows <- pairwise_id_d %>%
filter(!is.finite(identity) | identity < 80 | identity > 100)
print(bad_rows)
####
# Make the plot
# fix order of d
pairwise_id_d$swarm_d <- factor(pairwise_id_d$swarm_d, levels = unique(pairwise_id_d$swarm_d))
p <-ggplot(pairwise_id_d, aes(x = identity, fill = cluster)) +
geom_density(adjust = 1.5, alpha = 0.4) +
scale_x_continuous(limits = c(80, 100)) +
facet_wrap(~swarm_d, scales = "free_y") +  # one subplot per d
ggtitle("Pairwise percent idnetity between ASV ofthe same or different cluster according Swarm's d") +
theme_minimal()
###
if(outfile != ""){
check_dir(outfile, is_file=TRUE)
png(filename=outfile) # one png file per plot
print(p) # print plot to file
dev.off()
}
return(p)
} # end function
plot <- PairwiseIdentityPlotPerSwarmD(read_count_df,
swarm_d_min=1,
swarm_d_max=15,
swarm_d_increment=1,
min_id = 0.8,
vsearch_path=vsearch_path,
swarm_path=swarm_path,
num_threads=0,
outfile="density_plot_1_15.png")
}
PairwiseIdentityPlotPerSwarmD <- function(read_count,
swarm_d_min=1,
swarm_d_max=15,
swarm_d_increment=1,
min_id = 0.8,
vsearch_path="vsearch",
swarm_path="swarm",
num_threads=0,
outfile="",
sep=",",
quiet=TRUE
){
##### make df if read_count is file
if(is.character(read_count)){
read_count_df <- read.csv(read_count, header=T, sep=sep)
}else{
read_count_df <- read_count
}
#####
# make pairwise_id df with query, target, identity
pairwise_id <- PairwiseIdentity(read_count_df, min_id = 0.8, vsearch_path=vsearch_path, quiet=TRUE, num_threads=0)
#####
# make a df with unique asv, asv_id and readcount (sum)
asv_df <- read_count_df %>%
group_by(asv, asv_id) %>%
summarize(rc = sum(read_count), .groups="drop")
#####
# make a fasta file with unique asv format adapted to swarm
input_swarm <- file.path(tempdir(), "swarm_input.fasta")
writeLines(paste(">", asv_df$asv_id, "_",
asv_df$rc, "\n",
asv_df$asv,
sep=""),
input_swarm)
#####
# initialize data frame (cluster: same/different)
pairwise_id_d <- data.frame(identity = numeric(),
cluster = character(),
swarm_d= factor())
#####
# for each d
for(d in seq(swarm_d_min, swarm_d_max, by=swarm_d_increment)){
print(d)
#####
# run swarm
# make tmp dir separatelit for each d
tmp_dir <-paste('tmp_swarm_', d, '_', trunc(as.numeric(Sys.time())), sample(1:100, 1), sep='')
tmp_dir <- file.path(tempdir(), tmp_dir)
check_dir(tmp_dir)
# clusters.txt each line is a cluster, with asv_ids separated  by space
clusters <- file.path(tmp_dir, "clusters.txt")
swarm <- paste(swarm_path, " -d ", d, " -o ", clusters, sep="")
if(num_threads > 0){ # if num_threads have been specified
swarm <- paste(swarm, " -t ", num_threads, sep="")
}
swarm <- paste(swarm, input_swarm, sep=" ")
if(!quiet){
print(swarm)
}
system(swarm)
#####
# make a data frame with cluster_id and asv_id columns,
# where asv_id has all swarm input asv_id,
# and  cluster_id is the name of the cluster they belong to
# read.table is unpredictable. Use a more complicated, but more sure solution.
# Read the file line by line
lines <- readLines(clusters)
# Split each line by whitespace
split_lines <- strsplit(lines, "[[:space:]]+")
# Determine the maximum number of fields
max_cols <- max(sapply(split_lines, length))
# Convert to a data frame and fill empty cells by NA
#    cluster_df <- as.data.frame(do.call(rbind, lapply(split_lines, function(x) c(x, rep(NA, max_cols - length(x))))),
#                                stringsAsFactors = FALSE)
cluster_df <- as.data.frame(
do.call(
rbind, lapply(
split_lines,
function(x) c(x, rep(NA, max_cols - length(x)))
)
),
stringsAsFactors = FALSE
)
#  repeat each cluster_id as many times as columns
# transpose and flatten to make asv_id
# This will produce some lines with NA for asv_id. Filter them out afterwards.
cluster_df <- data.frame(cluster_id = rep(cluster_df$V1,
each = ncol(cluster_df)),
asv_id = as.vector(t(cluster_df[,])))
# delete lines with NA values in asv_id
cluster_df <- cluster_df %>%
filter(!is.na(asv_id))
# delete read_counts from id
cluster_df$cluster_id <- as.numeric(
sub("_[0-9]+", "", cluster_df$cluster_id ))
cluster_df$asv_id <- as.numeric(
sub("_[0-9]+", "", cluster_df$asv_id ))
#####
# add to pairwise_id the clusters of each query and target and define
# if they are in the same or different clusters
pairwise_id_local <- left_join(pairwise_id, cluster_df, by=c("query"="asv_id")) %>%
rename(cluster_id_query = cluster_id)
pairwise_id_local <- left_join(pairwise_id_local, cluster_df, by=c("target"="asv_id")) %>%
rename(cluster_id_target = cluster_id)
# add within/between column, and the d for each line
pairwise_id_local <- pairwise_id_local %>%
mutate(cluster = ifelse(cluster_id_query == cluster_id_target, "same", "different")) %>%
mutate(swarm_d=paste0("swarm's d: ",d)) %>%
select(identity, cluster, swarm_d)
# add lines to the oveall df
pairwise_id_d <- rbind(pairwise_id_d, pairwise_id_local)
} # end for
bad_rows <- pairwise_id_d %>%
filter(!is.finite(identity) | identity < 80 | identity > 100)
print(bad_rows)
####
# Make the plot
# fix order of d
pairwise_id_d$swarm_d <- factor(pairwise_id_d$swarm_d, levels = unique(pairwise_id_d$swarm_d))
p <-ggplot(pairwise_id_d, aes(x = identity, fill = cluster)) +
geom_density(adjust = 1.5, alpha = 0.4) +
scale_x_continuous(limits = c(80, 100)) +
facet_wrap(~swarm_d, scales = "free_y") +  # one subplot per d
ggtitle("Pairwise percent idnetity between ASV ofthe same or different cluster according Swarm's d") +
theme_minimal()
###
if(outfile != ""){
check_dir(outfile, is_file=TRUE)
png(filename=outfile) # one png file per plot
print(p) # print plot to file
dev.off()
}
return(p)
} # end function
plot <- PairwiseIdentityPlotPerSwarmD(read_count_df,
swarm_d_min=1,
swarm_d_max=15,
swarm_d_increment=1,
min_id = 0.8,
vsearch_path=vsearch_path,
swarm_path=swarm_path,
num_threads=0,
outfile="density_plot_1_15.png")
tmp <- PairwiseIdentity(read_count_df,
min_id = 0.8,
vsearch_path=vsearch_path)
View(tmp)
View(tmp)
class(tmp$identity)
#' asv pairs with identity bellow min_id are not listed.
#' @examples
#' \dontrun{
#' identity_df <- PairwiseIdentity(asv,
#'                                 min_id = 0.8,
#'                                 vsearch_path=vsearch,
#'                                 num_threads=8)
#' }
#' @export
#'
PairwiseIdentity <- function(asv,
min_id = 0.8,
vsearch_path=vsearch,
num_threads=0,
outfile="",
sep=",",
quiet=TRUE
){
# can accept df or file as an input
if(is.character(asv)){
# read known occurrences
asv_df <- read.csv(asv, header=T, sep=sep)
}else{
asv_df <- asv
}
#### get unique asv list and make fasta file
asv_df <- asv_df %>%
select(asv, asv_id) %>%
distinct()
t <- check_one_to_one_relationship(asv_df) # stop execution, if FALSE
fasta <- file.path(tempdir(), "asv.fasta")
print(fasta)
write_fasta_df(asv_df, outfile=fasta, read_count=FALSE)
### run vsearch allpairs_global
vsearch_out <- file.path(tempdir(), "vsearch_out.tsv")
cmd <- paste(vsearch_path, "--allpairs_global", fasta, "--userout", vsearch_out,
'--userfields "query+target+id+ids+alnlen+aln"',
"--id", min_id, "--threads", num_threads, sep=" ")
if(!quiet){
print(cmd)
}
system(cmd)
#### read vsearch result
if(file.exists(vsearch_out) && file.size(vsearch_out) > 0){
# read vsearch results
results_vsearch<- read.csv(vsearch_out, header = FALSE, sep="\t")
colnames(results_vsearch) <- c("query","target","identity","nb_ids","aln_length","aln")
# none of the values easily outputted by vsearch take into the external gaps as a diff
# => correct this, based on the alnlen and the number of identities
# in a correctly filtered data set this correction should not make a big difference, but it does
# in unfiltered data sets, with strongly variable asv length.
results_vsearch$id_bis <- round(results_vsearch$nb_ids / nchar(results_vsearch$aln) * 100, digits=1)
results_vsearch <- results_vsearch %>%
select(query, target, identity=id_bis) %>%
mutate(identity = as.numeric(identity)) %>%
filter(identity >= min_id)
results_vsearch$query <- as.numeric(results_vsearch$query)
results_vsearch$target <- as.numeric(results_vsearch$target)
} else {
results_vsearch <- data.frame(query=numeric(),
target= numeric(),
identity= numeric())
}
#### write csv
if(outfile != ""){
check_dir(outfile, is_file=TRUE)
write.table(out_df, file = outfile,  row.names = F, sep=sep)
}
return(results_vsearch)
}
plot <- PairwiseIdentityPlotPerSwarmD(read_count_df,
swarm_d_min=1,
swarm_d_max=15,
swarm_d_increment=1,
min_id = 0.8,
vsearch_path=vsearch_path,
swarm_path=swarm_path,
num_threads=0,
outfile="density_plot_1_15.png")
knitr::opts_chunk$set(echo = TRUE, eval=FALSE)
### If pb with vignette not building correctly
# clean package
unlink("~/R/x86_64-pc-linux-gnu-library/4.0/vtamR", recursive = TRUE, force = TRUE)
file.exists("~/R/x86_64-pc-linux-gnu-library/4.0/vtamR")
# Clean and regenerate documentation:
devtools::clean_dll()
devtools::document()
devtools::install(build_vignettes = FALSE, force = TRUE)
# install with vignettes (local)
devtools::install(build_vignettes = TRUE)
### If pb with vignette not building correctly
# clean package
unlink("~/R/x86_64-pc-linux-gnu-library/4.0/vtamR", recursive = TRUE, force = TRUE)
file.exists("~/R/x86_64-pc-linux-gnu-library/4.0/vtamR")
# Clean and regenerate documentation:
devtools::clean_dll()
devtools::document()
devtools::document()
# install with vignettes (local)
devtools::install(build_vignettes = TRUE)
vignette(package = "vtamR")
