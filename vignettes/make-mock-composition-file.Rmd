---
title: "How to make a mock_composition file"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{How to make a mock_composition file}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  echo=TRUE,
  eval=FALSE,
  comment = "#>"
)
```


## What is it and when to use it

The [mock_composition](tutorial-vtamr-pipeline.html#mock_composition) file is 
a CSV file with the following columns:

 * sample: Name of the [mock](tutorial-vtamr-pipeline.html#glossary) sample
 * action: 
      * `keep`: Expected ASV in the mock, that should be kept in the data set
      * `tolerate`: ASV that can be present in a mock, but it is not essential to keep it in the data set (e.g. badly amplified organism)
 * [asv](tutorial-vtamr-pipeline.html#glossary): sequence of the ASV
 * taxon: Optional; Name of the organism
 * [asv_id](tutorial-vtamr-pipeline.html#glossary): Optional; If there is a conflict between asv and asv_id, the asv_id is ignored

This file is essential in the 
`MakeKnownOccurrences` function, that 

- identifies known False Positives (FP) in control samples (mock and negative controls), 
- identifies missing occurrences (FN = False Negatives in mock samples) 
- calculates performance metrics (precision and sensitivity) based on control samples.
- produces a known_occurrences file or data frame with the list of 
expected occurrences (TP = True Positives) in mock samples and FP in all control samples.

The [known_occurrences](tutorial-vtamr-pipeline.html#known_occurrences) 
file is necessary for running the Optimize functions 
(`OptimizePCRerror`, `OptimizeLFNsampleReplicate`, `OptimizeLFNreadCountLFNvariant`)
to find the best parameter values for the LFN filters 
(`LFNsampleReplicate`, `LFNvariant`, `LFNreadCount`) and `FilterPCRerror`.

The [mock_composition](tutorial-vtamr-pipeline.html#mock_composition) is also useful, 
although not essential for the `WriteASVtable` function if you wish to add a column in 
the output to easily find expected occurrences in each mock sample.

## Make mock_composition

I will show you here how to identify the expected mock ASV form your data.

I suggest that you start by filtering/denoising your dataset by using at least some of
the following functions. This will eliminate most of the erroneous ASV, so
it will be easier to identify the expected ASV from your mock samples. 
(See [tutorial-vtamr-pipeline](tutorial-vtamr-pipeline.html) vignette.)

- [Swarm](tutorial-vtamr-pipeline.html#Swarm)
- [LFNglobalReadCount](tutorial-vtamr-pipeline.html#LFNglobalReadCount)
- [FilterIndel](tutorial-vtamr-pipeline.html#FilterIndel)
- [FilterCodonStop](tutorial-vtamr-pipeline.html#FilterCodonStop)
- [FilterChimera](tutorial-vtamr-pipeline.html#FilterChimera)
- [FilterRenkonen](tutorial-vtamr-pipeline.html#FilterRenkonen)

Then you can make the `mock_composition` file, which is essential for the optimize 
functions, which in turn suggest parameter values for 
`FilterPCRerror`, `LFNsampleReplicate`, `LFNvariant` and `LFNreadCount`.

### Assign taxa to ASVs

See more details of taxonomic assignment [here](tutorial-vtamr-pipeline.html#taxassign).
```{r}
taxonomy <- "~/mkCOInr/COInr/COInr_for_vtam_2025_05_23_dbV5/COInr_for_vtam_taxonomy.tsv"
blast_db <- "~/mkCOInr/COInr/COInr_for_vtam_2025_05_23_dbV5/COInr_for_vtam"
asv_tax <- TaxAssign(asv=read_count_df, 
                     taxonomy=taxonomy, 
                     blast_db=blast_db, 
                     blast_path=blast_path, 
                     num_threads=8
                     )
```

### Pool replicates by sample

See details of PoolReplicates [here](tutorial-vtamr-pipeline.html#poolreplicates).
```{r}
read_count_samples_df <- PoolReplicates(read_count_df)
```

### Make an ASV table with taxonomic assignments

Make a data frame with ASVs and read counts in the 
[wide format](tutorial-vtamr-pipeline.html#glossary) 
and add the total number of reads for each ASV, 
the number of samples they are present and their taxonomic assignment. 
This format is easier to read for humans, than the `read_count_df`.

See details of `WriteASVtable` [here](tutorial-vtamr-pipeline.html#print-output).

```{r}
outdir <- "~/vtamR_demo/out_mfzr"
sorted_dir <- file.path(outdir, "sorted")
sortedinfo <- file.path(sorted_dir, "sortedinfo.csv")
tmp_asv_table <- WriteASVtable(read_count_samples_df, 
                               sortedinfo=sortedinfo, 
                               add_sums_by_asv=T, 
                               asv_tax=asv_tax)
```

If there are many samples it might be better to select only mock samples 
and pertinent columns.
In this example, `tpos1` is the name of one of the mock samples. 
You can do this separately for each mock.
```{r}
asv_tpos1 <- tmp_asv_table %>%
  select(tpos1, Total_number_of_reads, Number_of_samples, asv_id, 
         phylum, class, order, family, genus, species, asv
         ) %>%
  filter(tpos1 > 0) %>%
  arrange(desc(tpos1))
```

In this mock sample, there should be the following 6 species:

- *Caenis pusilla*
- *Rheocricotopus*
- *Phoxinus phoxinus*
- *Hydropsyche pellucidula*
- *Synorthocladius semivirens*
- *Baetis rhodani*

We can see that in spite of all the filtering we have done so far, there are still
a lot of unexpected occurrences in this sample. 
Most of them have low read counts and could be filtered out by 
[Low Frequency Noise Filters](tutorial-vtamr-pipeline.html#glossary)

### Select the expected ASV and make mock_composition

You can now pick the correct sequences of the expected ASVs in each mock and make the [mock_composition](tutorial-vtamr-pipeline.html#mock_composition) file.

